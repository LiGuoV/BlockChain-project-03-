// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')
const truffleAssert = require('truffle-assertions');

var instance, accounts, owner, farmer, distributor, retailer, consumer
const emptyAddress = '0x00000000000000000000000000000000000000'
var sku = 1
var upc = 1
const farmName = "John Doe"
const farmInformation = "Yarray Valley"
const farmLatitude = "-38.239770"
const farmLongitude = "144.341490"
var pID = sku + upc
const pNotes = "Best beans for Espresso"
const pPrice = web3.utils.toWei('1', "ether")

contract('SupplyChain', function (accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    owner = accounts[0]
    farmer = accounts[1]
    distributor = accounts[2]
    retailer = accounts[3]
    consumer = accounts[4]

})


before(async () => {
    instance = await SupplyChain.deployed()
    await instance.addFarmer(farmer, { from: owner });
    await instance.addDistributor(distributor, { from: owner })
    await instance.addRetailer(retailer, { from: owner })
    await instance.addConsumer(consumer, { from: owner })
})
// 1st Test
it("Testing smart contract function harvestItem() that allows a farmer to harvest coffee", async () => {


    // Mark an item as Harvested by calling function harvestItem()

    let tx = await instance.harvestItem(upc, farmer, farmName, farmInformation, farmLatitude, farmLongitude, pNotes, { from: farmer })
    truffleAssert.eventEmitted(tx, 'Harvested');

    // Retrieve the just now saved item from blockchain by calling function fetchItem()

    const { itemSKU,
        itemUPC,
        ownerID,
        originFarmerID,
        originFarmName,
        originFarmInformation,
        originFarmLatitude,
        originFarmLongitude } = await instance.fetchItemBufferOne.call(upc)

    const {
        productID,
        productNotes,
        productPrice,
        itemState,
        distributorID,
        retailerID,
        consumerID } = await instance.fetchItemBufferTwo.call(upc)

    // Verify the result set
    assert.equal(itemSKU, sku, 'Error: Invalid item SKU')
    assert.equal(itemUPC, upc, 'Error: Invalid item UPC')
    assert.equal(ownerID, farmer, 'Error: Missing or Invalid ownerID')
    assert.equal(originFarmerID, farmer, 'Error: Missing or Invalid originFarmerID')
    assert.equal(originFarmName, farmName, 'Error: Missing or Invalid originFarmName')
    assert.equal(originFarmInformation, farmInformation, 'Error: Missing or Invalid originFarmInformation')
    assert.equal(originFarmLatitude, farmLatitude, 'Error: Missing or Invalid originFarmLatitude')
    assert.equal(originFarmLongitude, farmLongitude, 'Error: Missing or Invalid originFarmLongitude')
    assert.equal(itemState, 0, 'Error: Invalid item State')
    assert.equal(productID, pID,)
    assert.equal(productNotes, pNotes)
})

// 2nd Test
it("Testing smart contract function processItem() that allows a farmer to process coffee", async () => {


    // Watch the emitted event Processed()
    // Mark an item as Processed by calling function processtItem()
    let tx = await instance.processItem(upc, { from: farmer })
    truffleAssert.eventEmitted(tx, 'Processed')

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set
    const { itemState } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 1)

})

// 3rd Test
it("Testing smart contract function packItem() that allows a farmer to pack coffee", async () => {
    // Watch the emitted event Packed()
    // Mark an item as Packed by calling function packItem()
    let tx = await instance.packItem(upc, { from: farmer })
    truffleAssert.eventEmitted(tx, 'Packed')
    const { itemState } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 2)

})

// 4th Test
it("Testing smart contract function sellItem() that allows a farmer to sell coffee", async () => {
    // Watch the emitted event ForSale()
    // Mark an item as ForSale by calling function sellItem()
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set
    let tx = await instance.sellItem(upc, pPrice, { from: farmer })
    truffleAssert.eventEmitted(tx, 'ForSale')
    const { itemState, productPrice } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 3)
    assert.equal(productPrice, pPrice)

})

// 5th Test
it("Testing smart contract function buyItem() that allows a distributor to buy coffee", async () => {
    // Watch the emitted event Sold()
    // Mark an item as Sold by calling function buyItem()
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set
    const farmer_before_balance = web3.utils.toBN(await web3.eth.getBalance(farmer))

    let tx = await instance.buyItem(upc, { from: consumer, value: pPrice * 2 })
    truffleAssert.eventEmitted(tx, 'Sold')
    const { itemState } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 4)
    const farmer_after_balance = web3.utils.toBN(await web3.eth.getBalance(farmer))

    assert.equal(
        farmer_before_balance.add(web3.utils.toBN(pPrice)).toString(),
        farmer_after_balance.toString())
})

// 6th Test
it("Testing smart contract function shipItem() that allows a distributor to ship coffee", async () => {
    // Watch the emitted event Shipped()
    // Mark an item as Sold by calling function shipItem()
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set
    let tx = await instance.shipItem(upc, { from: distributor })
    truffleAssert.eventEmitted(tx, 'Shipped')
    const { itemState, distributorID } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 5)
    assert.equal(distributorID, distributor)

})

// 7th Test
it("Testing smart contract function receiveItem() that allows a retailer to mark coffee received", async () => {
    // Watch the emitted event Received()
    // Mark an item as Sold by calling function receiveItem()
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set
    let tx = await instance.receiveItem(upc, { from: retailer })
    truffleAssert.eventEmitted(tx, 'Received')
    const { itemState } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 6)

})

// 8th Test
it("Testing smart contract function purchaseItem() that allows a consumer to purchase coffee", async () => {
    // Watch the emitted event Purchased()
    // Mark an item as Sold by calling function purchaseItem()
    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set
    let tx = await instance.purchaseItem(upc, { from: consumer })
    truffleAssert.eventEmitted(tx, 'Purchased')
    const { itemState } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(itemState, 7)
})

// 9th Test
it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async () => {

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    const { itemSKU,
        itemUPC,
        ownerID,
        originFarmerID,
        originFarmName,
        originFarmInformation,
        originFarmLatitude,
        originFarmLongitude } = await instance.fetchItemBufferOne.call(upc)

    assert.equal(itemUPC, upc)
    assert.equal(itemSKU, sku)
    assert.equal(ownerID, consumer)
    assert.equal(originFarmerID, farmer)

})

// 10th Test
it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async () => {

    // Retrieve the just now saved item from blockchain by calling function fetchItem()
    // Verify the result set:
    const {
        productID,
        productNotes,
        productPrice,
        itemState,
        distributorID,
        retailerID,
        consumerID } = await instance.fetchItemBufferTwo.call(upc)
    assert.equal(productID, pID)
    assert.equal(productPrice, pPrice)
    assert.equal(distributorID, distributor)
    assert.equal(retailerID, retailer)
    assert.equal(consumerID, consumer)

})

